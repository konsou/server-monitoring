#!/usr/bin/env python3
# Runs a short SMART test for all devices
import json
import logging
import subprocess
import sys
import time

from pathlib import Path
from typing import NamedTuple

import _discord

LOG_FILE = Path("/var/log/smart.log")
logging.basicConfig(filename=LOG_FILE, level=logging.INFO)
logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(sys.stdout))


class DeviceTestResult(NamedTuple):
    device: str
    human_readable_name: str
    passed: bool
    human_readable_error_info: str = ""


class TestResults(NamedTuple):
    passed: bool
    results: tuple[DeviceTestResult, ...]


def device_info(device: str) -> dict:
    i = subprocess.run(
        ["smartctl", "--xall", "--json", str(device)], stdout=subprocess.PIPE
    ).stdout.decode("utf-8")
    return json.loads(i)


def human_readable_error_info(device: str) -> str:
    i = subprocess.run(
        ["smartctl", "--log=selftest", "--log=error", "--log=xerror", str(device)],
        stdout=subprocess.PIPE,
    ).stdout.decode("utf-8")
    return i


def human_readable_name(info_dict: dict) -> str:
    GB = 1024**3
    capacity_bytes = (
        info_dict.get("user_capacity", {}).get("bytes", None)
        or info_dict.get("nvme_total_capacity", None)
        or -1
    )
    return f"{info_dict.get('model_name', 'UNKNOWN')} - {capacity_bytes / GB:.1f}GB"


def poll_time(info_dict: dict) -> int:
    try:
        return int(
            info_dict["ata_smart_data"]["self_test"]["polling_minutes"]["short"] * 60
        )
    except KeyError:
        # Polling time not available - default
        return 60


def test_in_progress(info_dict: dict) -> bool:
    if "ata_smart_data" in info_dict:
        val = (
            info_dict.get("ata_smart_data", {})
            .get("self_test", {})
            .get("status", {})
            .get("string", "")
        )
        return "in progress" in val
    return bool(
        info_dict.get("nvme_self_test_log", {})
        .get("current_self_test_operation", {})
        .get("value", 0)
    )


def test_passed(info_dict: dict) -> bool:
    if "ata_smart_data" in info_dict:
        return (
            info_dict.get("ata_smart_data", {})
            .get("self_test", {})
            .get("status", {})
            .get("passed", False)
        )

    try:
        result = (
            info_dict.get("nvme_self_test_log", {})
            .get("table", [])[0]
            .get("self_test_result", {})
            .get("value", 1)
        )
        # result value 0 = passed - flip to get success boolean
        return not result
    # nvme self test log doesn't exist
    except IndexError:
        return False


def scan_devices() -> list[str]:
    entries = subprocess.run(
        ["smartctl", "--scan", "--json"], stdout=subprocess.PIPE
    ).stdout.decode("utf-8")
    parsed = json.loads(entries)
    return [d["info_name"] for d in parsed["devices"]]


def test_one(device: str) -> DeviceTestResult:
    _device_info = device_info(device)
    _poll_time = poll_time(_device_info)
    logger.info(f"Starting short self-test for {device}...")
    subprocess.run(
        ["smartctl", "--test=short", "--json", str(device)], stdout=subprocess.PIPE
    ).stdout.decode("utf-8")
    logger.info(f"Polling results every {_poll_time / 60} minutes")
    while True:
        time.sleep(_poll_time)
        _device_info = device_info(device)
        if not test_in_progress(_device_info):
            break
        logger.info(
            f"Test still in progress. Waiting another {_poll_time / 60} minutes",
        )
    passed = test_passed(_device_info)
    _human_readable_name = human_readable_name(_device_info)
    if passed:
        logger.info(f"passed: {device} - {_human_readable_name}")
        error_info = ""
    else:
        logger.error(f"FAILED: {device} - {_human_readable_name}")
        error_info = human_readable_error_info(device)
    return DeviceTestResult(
        device=device,
        human_readable_name=_human_readable_name,
        passed=passed,
        human_readable_error_info=error_info,
    )


def test_all() -> TestResults:
    tests_passed = True
    devices = scan_devices()
    device_results = []
    for device in devices:
        result = test_one(device)
        device_results.append(result)
        tests_passed = tests_passed and result.passed
    return TestResults(passed=tests_passed, results=tuple(device_results))


if __name__ == "__main__":
    logger.info("Starting SMART short test for all devices")
    _discord.notify_discord("Starting SMART short test for all devices")
    result = test_all()
    logger.info(f"{result=}")

    if result.passed:
        discord_msg = ["SMART short tests passed"]
    else:
        discord_msg = ["SMART short tests FAILED!"]
    for r in result.results:
        if r.passed:
            discord_msg.append(f"passed: {r.device} - {r.human_readable_name}")
        else:
            discord_msg.append(f"FAILED: {r.device} - {r.human_readable_name}")
            discord_msg.append(r.human_readable_error_info)
    _discord.notify_discord("\n".join(discord_msg), is_error=not result.passed)

    exit(not result.passed)
